<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake Game - Boss Edition</title>
<style>
  /* Font */
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@500;800&display=swap');
  /* Reset e base */
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body {
    height:100%; 
    font-family: 'Poppins', sans-serif; 
    background:#222738; 
    color:#6e7888; 
    display:flex; 
    justify-content:center; 
    align-items:center;
    user-select:none;
  }
  button:focus { outline:none; }
  /* Container centrale */
  .container {
    display:flex; 
    flex-direction:column; 
    justify-content:center; 
    align-items:center; 
    width:100vw; 
    height:100vh;
  }
  /* Wrapper flex per bottone + canvas + UI */
  .wrapper {
    display:flex; 
    flex-wrap:wrap; 
    justify-content:center; 
    align-items:center;
    margin-bottom:20px;
  }
  /* Bottone restart */
  #replay {
    font-size: 10px;
    padding: 10px 20px;
    background: #6e7888;
    border: none;
    color: #222738;
    border-radius: 40px;
    font-weight: 800;
    transform: rotate(270deg);
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    margin-right: 15px;
  }
  #replay:hover {
    background: #4cffd7;
  }
  #replay i {
    margin-right: 8px;
  }
  /* Canvas */
  canvas {
    background-color: #181825;
    image-rendering: pixelated;
    box-shadow: 0 0 10px #4cffd7;
  }
  /* UI punteggio */
  #ui {
    display:flex;
    flex-direction: column;
    align-items: center;
    margin-left: 10px;
    font-size: 10px;
  }
  #ui h2 {
    font-weight: 900;
    font-size: 10px;
    letter-spacing: 8px;
    margin-bottom: 30px;
    transform: rotate(270deg);
  }
  #score {
    font-size: 30px;
    font-weight: 800;
    transform: rotate(-90deg);
    margin-top: 20px;
  }
  /* Controlli mobile */
  .mobile-controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 100;
  }
  .mobile-controls .ctrl {
    font-size: 24px;
    width: 60px;
    height: 60px;
    margin: 5px;
    border-radius: 50%;
    border: none;
    background-color: #4cffd7;
    color: #222738;
    font-weight: bold;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    cursor: pointer;
    user-select:none;
  }
  .mobile-controls .horizontal {
    display: flex;
    gap: 10px;
  }
  /* Nascondi controlli su desktop */
  @media (min-width: 768px) {
    .mobile-controls {
      display: none;
    }
  }
  /* Responsive */
  @media (max-width: 600px) {
    #replay {
      margin-bottom: 20px;
      transform: rotate(0deg);
    }
    #ui {
      flex-direction: row;
      margin-bottom: 20px;
    }
    #ui h2 {
      transform: rotate(0deg);
      margin-right: 10px;
    }
    #score {
      margin-top: 0;
      margin-left: 0;
      transform: rotate(0deg);
    }
    .wrapper {
      flex-direction: column;
    }
  }
</style>
</head>
<body>
<div class="container noselect">
  <div class="wrapper">
    <button id="replay"><i class="fas fa-play"></i>RESTART</button>
    <div id="canvas"></div>
    <div id="ui">
      <h2>SCORE</h2>
      <span id="score">00</span>
    </div>
  </div>
</div>

<!-- Controlli mobile -->
<div class="mobile-controls">
  <button class="ctrl" data-dir="ArrowUp">↑</button>
  <div class="horizontal">
    <button class="ctrl" data-dir="ArrowLeft">←</button>
    <button class="ctrl" data-dir="ArrowDown">↓</button>
    <button class="ctrl" data-dir="ArrowRight">→</button>
  </div>
</div>

<!-- FontAwesome per icona -->
<script defer src="https://pro.fontawesome.com/releases/v5.10.0/js/all.js" integrity="sha384-G/ZR3ntz68JZrH4pfPJyRbjW+c0+ojii5f+GYiYwldYU69A+Ejat6yIfLSxljXxD" crossorigin="anonymous"></script>

<script>
  // Setup canvas e variabili
  let dom_replay = document.querySelector("#replay");
  let dom_score = document.querySelector("#score");
  let dom_canvas = document.createElement("canvas");
  document.querySelector("#canvas").appendChild(dom_canvas);
  let CTX = dom_canvas.getContext("2d");

  const W = (dom_canvas.width = 400);
  const H = (dom_canvas.height = 400);

  let snake, food, currentHue, cells = 20, cellSize, isGameOver = false, score = 0, maxScore = window.localStorage.getItem("maxScore") || 0, particles = [], splashingParticleCount = 20, requestID;

  // Helpers vari
  let helpers = {
    Vec: class {
      constructor(x, y) { this.x = x; this.y = y; }
      add(v) { this.x += v.x; this.y += v.y; return this; }
      mult(v) {
        if (v instanceof helpers.Vec) { this.x *= v.x; this.y *= v.y; return this; }
        else { this.x *= v; this.y *= v; return this; }
      }
    },
    isCollision(v1, v2) { return v1.x === v2.x && v1.y === v2.y; },
    garbageCollector() {
      for(let i=particles.length-1; i>=0; i--) {
        if(particles[i].size <= 0) particles.splice(i,1);
      }
    },
    drawGrid() {
      CTX.lineWidth = 1.1;
      CTX.strokeStyle = "#232332";
      CTX.shadowBlur = 0;
      for(let i=1; i<cells; i++) {
        let f = (W / cells) * i;
        CTX.beginPath();
        CTX.moveTo(f, 0);
        CTX.lineTo(f, H);
        CTX.stroke();
        CTX.beginPath();
        CTX.moveTo(0, f);
        CTX.lineTo(W, f);
        CTX.stroke();
        CTX.closePath();
      }
    },
    randHue() { return ~~(Math.random()*360); },
    hsl2rgb(h, s, l) {
      if(h===undefined) return [0,0,0];
      let c = (1 - Math.abs(2*l - 1)) * s;
      let hp = h / 60;
      let x = c * (1 - Math.abs((hp % 2) -1));
      let r=0, g=0, b=0;
      if(hp>=0 && hp<1){r=c;g=x;b=0;}
      else if(hp>=1 && hp<2){r=x;g=c;b=0;}
      else if(hp>=2 && hp<3){r=0;g=c;b=x;}
      else if(hp>=3 && hp<4){r=0;g=x;b=c;}
      else if(hp>=4 && hp<5){r=x;g=0;b=c;}
      else if(hp>=5 && hp<6){r=c;g=0;b=x;}
      let m = l - c/2;
      return [Math.round((r+m)*255), Math.round((g+m)*255), Math.round((b+m)*255)];
    },
    lerp(start,end,t) { return start*(1-t) + end*t; }
  };

  // Gestione tasti
  let KEY = {
    ArrowUp:false,
    ArrowRight:false,
    ArrowDown:false,
    ArrowLeft:false,
    resetState() { this.ArrowUp=false; this.ArrowRight=false; this.ArrowDown=false; this.ArrowLeft=false; },
    listen() {
      addEventListener("keydown", e=>{
        if(e.key==="ArrowUp" && this.ArrowDown) return;
        if(e.key==="ArrowDown" && this.ArrowUp) return;
        if(e.key==="ArrowLeft" && this.ArrowRight) return;
        if(e.key==="ArrowRight" && this.ArrowLeft) return;
        this.ArrowUp=this.ArrowRight=this.ArrowDown=this.ArrowLeft=false;
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
          this[e.key]=true;
        }
      }, false);
    }
  };

  // Classe Serpente
  class Snake {
    constructor() {
      this.pos = new helpers.Vec(W/2, H/2);
      this.dir = new helpers.Vec(0, 0);
      this.delay = 5;
      this.size = W / cells;
      this.color = "white";
      this.history = [];
      this.total = 1;
    }
    draw() {
      let {x,y} = this.pos;
      CTX.fillStyle = this.color;
      CTX.shadowBlur = 20;
      CTX.shadowColor = "rgba(255,255,255,.3)";
      CTX.fillRect(x, y, this.size, this.size);
      CTX.shadowBlur = 0;
      for(let i=0; i<this.history.length-1; i++) {
        let {x,y} = this.history[i];
        CTX.lineWidth=1;
        CTX.fillStyle = "rgba(225,225,225,1)";
        CTX.fillRect(x, y, this.size);
      }
    }
    walls() {
      let { x, y } = this.pos;
      if (x + this.size > W) this.pos.x = 0;
      if (y + this.size > H) this.pos.y = 0;
      if (x < 0) this.pos.x = W - this.size;
      if (y < 0) this.pos.y = H - this.size;
    }
    controls() {
      let dir = this.size;
      if (KEY.ArrowUp) this.dir = new helpers.Vec(0, -dir);
      if (KEY.ArrowDown) this.dir = new helpers.Vec(0, dir);
      if (KEY.ArrowLeft) this.dir = new helpers.Vec(-dir, 0);
      if (KEY.ArrowRight) this.dir = new helpers.Vec(dir, 0);
    }
    selfCollision() {
      for (let i = 0; i < this.history.length; i++) {
        let p = this.history[i];
        if (helpers.isCollision(this.pos, p)) {
          isGameOver = true;
        }
      }
    }
    update() {
      this.walls();
      this.draw();
      this.controls();
      if (!this.delay--) {
        if (helpers.isCollision(this.pos, food.pos)) {
          incrementScore();
          particleSplash();
          food.spawn();
          this.total++;
        }
        this.history[this.total - 1] = new helpers.Vec(this.pos.x, this.pos.y);
        for (let i = 0; i < this.total - 1; i++) {
          this.history[i] = this.history[i + 1];
        }
        this.pos.add(this.dir);
        this.delay = 5;
        if (this.total > 3) this.selfCollision();
      }
    }
  }

  class Food {
    constructor() {
      this.size = cellSize;
      this.spawn();
    }
    draw() {
      let { x, y } = this.pos;
      CTX.globalCompositeOperation = "lighter";
      CTX.shadowBlur = 20;
      CTX.shadowColor = this.color;
      CTX.fillStyle = this.color;
      CTX.fillRect(x, y, this.size, this.size);
      CTX.globalCompositeOperation = "source-over";
      CTX.shadowBlur = 0;
    }
    spawn() {
      let randX = ~~(Math.random() * cells) * this.size;
      let randY = ~~(Math.random() * cells) * this.size;
      for (let path of snake.history) {
        if (helpers.isCollision(new helpers.Vec(randX, randY), path)) {
          return this.spawn();
        }
      }
      this.pos = new helpers.Vec(randX, randY);
      this.color = currentHue = `hsl(${helpers.randHue()}, 100%, 50%)`;
    }
  }

  class Particle {
    constructor(pos, color, size, vel) {
      this.pos = new helpers.Vec(pos.x, pos.y);
      this.color = color;
      this.size = Math.abs(size / 2);
      this.ttl = 0;
      this.gravity = -0.2;
      this.vel = vel;
    }
    draw() {
      let [h, s, l] = this.color.match(/\d+/g).map(Number);
      let [r, g, b] = helpers.hsl2rgb(h, s / 100, l / 100);
      CTX.shadowColor = `rgba(${r},${g},${b},1)`;
      CTX.shadowBlur = 0;
      CTX.globalCompositeOperation = "lighter";
      CTX.fillStyle = `rgba(${r},${g},${b},1)`;
      CTX.fillRect(this.pos.x, this.pos.y, this.size, this.size);
      CTX.globalCompositeOperation = "source-over";
    }
    update() {
      this.draw();
      this.size -= 0.3;
      this.ttl++;
      this.pos.add(this.vel);
      this.vel.y -= this.gravity;
    }
  }

  function incrementScore() {
    score++;
    dom_score.innerText = score.toString().padStart(2, "0");
  }

  function particleSplash() {
    for (let i = 0; i < splashingParticleCount; i++) {
      let vel = new helpers.Vec(Math.random() * 6 - 3, Math.random() * 6 - 3);
      let position = new helpers.Vec(food.pos.x, food.pos.y);
      particles.push(new Particle(position, currentHue, food.size, vel));
    }
  }

  function clear() {
    CTX.clearRect(0, 0, W, H);
  }

  function gameOver() {
    if (!maxScore) maxScore = score;
    if (score > maxScore) maxScore = score;
    window.localStorage.setItem("maxScore", maxScore);
    CTX.fillStyle = "#4cffd7";
    CTX.textAlign = "center";
    CTX.font = "bold 30px Poppins, sans-serif";
    CTX.fillText("GAME OVER", W / 2, H / 2);
    CTX.font = "15px Poppins, sans-serif";
    CTX.fillText(`SCORE   ${score}`, W / 2, H / 2 + 60);
    CTX.fillText(`MAXSCORE   ${maxScore}`, W / 2, H / 2 + 80);
  }

  function reset() {
    score = 0;
    dom_score.innerText = "00";
    snake = new Snake();
    food.spawn();
    KEY.resetState();
    isGameOver = false;
    clearTimeout(requestID);
    loop();
  }

  function loop() {
    clear();
    if (!isGameOver) {
      requestID = setTimeout(loop, 1000 / 60);
      helpers.drawGrid();
      snake.update();
      food.draw();
      for (let p of particles) {
        p.update();
      }
      helpers.garbageCollector();
    } else {
      clear();
      gameOver();
    }
  }

  // Controlli Mobile: gestisci i bottoni freccia touch
  document.querySelectorAll(".mobile-controls .ctrl").forEach(btn => {
    btn.addEventListener("touchstart", e => {
      e.preventDefault();
      let dir = btn.getAttribute("data-dir");
      KEY.resetState();
      KEY[dir] = true;
    });
    btn.addEventListener("touchend", e => {
      e.preventDefault();
      KEY.resetState();
    });
  });

  // Eventi e inizializzazione
  dom_replay.addEventListener("click", reset);
  KEY.listen();
  cellSize = W / cells;
  snake = new Snake();
  food = new Food();
  loop();
</script>
</body>
</html>